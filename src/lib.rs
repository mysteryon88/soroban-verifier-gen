use anyhow::{Result, anyhow, bail};
use serde::Deserialize;
use std::{
    fs,
    path::{Path, PathBuf},
};

use ark_bls12_381::{Fq, Fq2, G1Affine as ArkG1, G2Affine as ArkG2};
use ark_serialize::CanonicalSerialize;
use core::str::FromStr;

/// Configuration options for generating a Soroban verifier contract.
#[derive(Debug, Clone)]
pub struct GenerateOptions {
    /// Path to the verification key JSON file (typically generated by circom/snarkjs).
    pub vk_json_path: PathBuf,
    /// Output directory where the contract crate will be generated.
    pub out_dir: PathBuf,
    /// Name of the generated crate (used in Cargo.toml).
    pub crate_name: String,
    /// Name of the contract struct in the generated code.
    pub contract_name: String,
}

#[derive(Deserialize, Debug)]
struct VerificationKeyJson {
    vk_alpha_1: [String; 3],
    vk_beta_2: [[String; 2]; 3],
    vk_gamma_2: [[String; 2]; 3],
    vk_delta_2: [[String; 2]; 3],
    #[serde(rename = "IC")]
    ic: Vec<[String; 3]>,
    #[serde(rename = "nPublic")]
    n_public: u32,
}

fn validate_vk(vk: &VerificationKeyJson) -> Result<()> {
    let expected = (vk.n_public + 1) as usize;
    if vk.ic.len() != expected {
        bail!(
            "Invalid VK: IC.len={} but nPublic={} requires {}",
            vk.ic.len(),
            vk.n_public,
            expected
        );
    }
    Ok(())
}

fn g1_uncompressed_bytes(x: &str, y: &str) -> Result<Vec<u8>> {
    let x = Fq::from_str(x).map_err(|_| anyhow!("bad Fq x"))?;
    let y = Fq::from_str(y).map_err(|_| anyhow!("bad Fq y"))?;
    let p = ArkG1::new(x, y);
    let mut out = vec![];
    p.serialize_uncompressed(&mut out)
        .map_err(|e| anyhow!("Serialization error: {}", e))?;
    Ok(out)
}

fn g2_uncompressed_bytes(x1: &str, x2: &str, y1: &str, y2: &str) -> Result<Vec<u8>> {
    let x1 = Fq::from_str(x1).map_err(|_| anyhow!("bad Fq x1"))?;
    let x2 = Fq::from_str(x2).map_err(|_| anyhow!("bad Fq x2"))?;
    let y1 = Fq::from_str(y1).map_err(|_| anyhow!("bad Fq y1"))?;
    let y2 = Fq::from_str(y2).map_err(|_| anyhow!("bad Fq y2"))?;
    let x = Fq2::new(x1, x2);
    let y = Fq2::new(y1, y2);
    let p = ArkG2::new(x, y);
    let mut out = vec![];
    p.serialize_uncompressed(&mut out)
        .map_err(|e| anyhow!("Serialization error: {}", e))?;
    Ok(out)
}

fn fmt_u8_list(bytes: &[u8]) -> String {
    bytes
        .iter()
        .map(|b| format!("0x{:02x}", b))
        .collect::<Vec<_>>()
        .join(", ")
}

fn emit_const(name: &str, size_expr: &str, bytes: &[u8]) -> String {
    format!(
        "const {name}: [u8; {size}] = [{vals}];\n",
        name = name,
        size = size_expr,
        vals = fmt_u8_list(bytes)
    )
}

fn render_contract_source(
    contract_name: &str,
    alpha: &[u8],
    beta: &[u8],
    gamma: &[u8],
    delta: &[u8],
    ic: &[Vec<u8>],
) -> String {
    let mut s = String::new();

    s.push_str("#![no_std]\n");
    s.push_str("use soroban_sdk::{\n");
    s.push_str("    contract, contracterror, contractimpl, contracttype,\n");
    s.push_str("    crypto::bls12_381::{Fr, G1Affine, G2Affine, G1_SERIALIZED_SIZE, G2_SERIALIZED_SIZE},\n");
    s.push_str("    Env, Vec,\n");
    s.push_str("};\n\n");

    s.push_str("#[contracterror]\n");
    s.push_str("#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]\n");
    s.push_str("#[repr(u32)]\n");
    s.push_str("pub enum Groth16Error {\n");
    s.push_str("    MalformedVerifyingKey = 0,\n");
    s.push_str("}\n\n");

    s.push_str("#[derive(Clone)]\n#[contracttype]\n");
    s.push_str("pub struct VerificationKey {\n");
    s.push_str("    pub alpha: G1Affine,\n");
    s.push_str("    pub beta: G2Affine,\n");
    s.push_str("    pub gamma: G2Affine,\n");
    s.push_str("    pub delta: G2Affine,\n");
    s.push_str("    pub ic: Vec<G1Affine>,\n");
    s.push_str("}\n\n");

    s.push_str("#[derive(Clone)]\n#[contracttype]\n");
    s.push_str("pub struct Proof {\n");
    s.push_str("    pub a: G1Affine,\n");
    s.push_str("    pub b: G2Affine,\n");
    s.push_str("    pub c: G1Affine,\n");
    s.push_str("}\n\n");

    s.push_str("// AUTO-GENERATED VK BYTES (uncompressed). DO NOT EDIT.\n");
    s.push_str(&emit_const("VK_ALPHA", "G1_SERIALIZED_SIZE", alpha));
    s.push_str(&emit_const("VK_BETA", "G2_SERIALIZED_SIZE", beta));
    s.push_str(&emit_const("VK_GAMMA", "G2_SERIALIZED_SIZE", gamma));
    s.push_str(&emit_const("VK_DELTA", "G2_SERIALIZED_SIZE", delta));
    s.push('\n');

    s.push_str(&format!(
        "const VK_IC: [[u8; G1_SERIALIZED_SIZE]; {}] = [\n",
        ic.len()
    ));
    for b in ic {
        s.push_str("    [");
        s.push_str(&fmt_u8_list(b));
        s.push_str("],\n");
    }
    s.push_str("];\n\n");

    s.push_str("fn vk(env: &Env) -> VerificationKey {\n");
    s.push_str("    let alpha = G1Affine::from_array(env, &VK_ALPHA);\n");
    s.push_str("    let beta  = G2Affine::from_array(env, &VK_BETA);\n");
    s.push_str("    let gamma = G2Affine::from_array(env, &VK_GAMMA);\n");
    s.push_str("    let delta = G2Affine::from_array(env, &VK_DELTA);\n\n");
    s.push_str("    let mut ic = Vec::new(env);\n");
    s.push_str("    for p in VK_IC.iter() {\n");
    s.push_str("        ic.push_back(G1Affine::from_array(env, p));\n");
    s.push_str("    }\n\n");
    s.push_str("    VerificationKey { alpha, beta, gamma, delta, ic }\n");
    s.push_str("}\n\n");

    s.push_str("#[contract]\n");
    s.push_str(&format!("pub struct {};\n\n", contract_name));

    s.push_str("#[contractimpl]\n");
    s.push_str(&format!("impl {} {{\n", contract_name));
    s.push_str("    pub fn verify_proof(env: Env, proof: Proof, pub_signals: Vec<Fr>) -> Result<bool, Groth16Error> {\n");
    s.push_str("        let bls = env.crypto().bls12_381();\n");
    s.push_str("        let vk = vk(&env);\n\n");
    s.push_str("        if pub_signals.len() + 1 != vk.ic.len() {\n");
    s.push_str("            return Err(Groth16Error::MalformedVerifyingKey);\n");
    s.push_str("        }\n\n");
    s.push_str("        let mut vk_x = vk.ic.get(0).unwrap();\n");
    s.push_str("        for (s, v) in pub_signals.iter().zip(vk.ic.iter().skip(1)) {\n");
    s.push_str("            let prod = bls.g1_mul(&v, &s);\n");
    s.push_str("            vk_x = bls.g1_add(&vk_x, &prod);\n");
    s.push_str("        }\n\n");
    s.push_str("        let neg_a = -proof.a;\n");
    s.push_str("        let vp1 = soroban_sdk::vec![&env, neg_a, vk.alpha, vk_x, proof.c];\n");
    s.push_str(
        "        let vp2 = soroban_sdk::vec![&env, proof.b, vk.beta, vk.gamma, vk.delta];\n\n",
    );
    s.push_str("        Ok(bls.pairing_check(vp1, vp2))\n");
    s.push_str("    }\n");
    s.push_str("}\n");

    s
}

fn render_contract_cargo_toml(crate_name: &str) -> String {
    // Версию soroban-sdk подстрой под свою.
    format!(
        r#"[package]
name = "{crate_name}"
version = "0.1.0"
edition = "2024"
publish = false

[lib]
crate-type = ["lib", "cdylib"]
doctest = false

[dependencies]
soroban-sdk = "25"

[dev-dependencies]
soroban-sdk = {{ version = "25", features = ["testutils"] }}
ark-bls12-381 = "0.5"
ark-serialize = "0.5"
"#
    )
}

/// Высокоуровневый API: читает vk.json и создаёт полноценный crate контракта
pub fn generate_verifier_contract_to_dir(opts: GenerateOptions) -> Result<()> {
    let vk_str = fs::read_to_string(&opts.vk_json_path)?;
    let vk: VerificationKeyJson = serde_json::from_str(&vk_str)?;
    validate_vk(&vk)?;

    // Конвертация VK -> байты (uncompressed)
    let alpha = g1_uncompressed_bytes(&vk.vk_alpha_1[0], &vk.vk_alpha_1[1])?;

    let beta = g2_uncompressed_bytes(
        &vk.vk_beta_2[0][0],
        &vk.vk_beta_2[0][1],
        &vk.vk_beta_2[1][0],
        &vk.vk_beta_2[1][1],
    )?;

    let gamma = g2_uncompressed_bytes(
        &vk.vk_gamma_2[0][0],
        &vk.vk_gamma_2[0][1],
        &vk.vk_gamma_2[1][0],
        &vk.vk_gamma_2[1][1],
    )?;

    let delta = g2_uncompressed_bytes(
        &vk.vk_delta_2[0][0],
        &vk.vk_delta_2[0][1],
        &vk.vk_delta_2[1][0],
        &vk.vk_delta_2[1][1],
    )?;

    let mut ic_bytes = Vec::with_capacity(vk.ic.len());
    for p in &vk.ic {
        ic_bytes.push(g1_uncompressed_bytes(&p[0], &p[1])?);
    }

    // Рендер исходников
    let lib_rs = render_contract_source(
        &opts.contract_name,
        &alpha,
        &beta,
        &gamma,
        &delta,
        &ic_bytes,
    );
    let cargo_toml = render_contract_cargo_toml(&opts.crate_name);

    // Пишем на диск
    write_file(&opts.out_dir.join("Cargo.toml"), &cargo_toml)?;
    write_file(&opts.out_dir.join("src").join("lib.rs"), &lib_rs)?;
    Ok(())
}

fn write_file(path: &Path, contents: &str) -> Result<()> {
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent)?;
    }
    fs::write(path, contents)?;
    Ok(())
}
